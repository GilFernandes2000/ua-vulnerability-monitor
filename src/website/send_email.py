# import necessary packages
from email.mime.multipart import MIMEMultipart
from email.mime.text import MIMEText
from variables import MY_ADDRESS, PASSWORD
from string import Template
#import the smtplib module. It should be included in Python by default
import smtplib
from sqlalchemy import *
from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String, ForeignKey

def get_key(my_dict, val):
    for key, value in my_dict.items():
         if val == value:
             return key
 
    return "key doesn't exist"

def main(domainNames):
    
    message_template = read_template('message.txt')
    

    engine = create_engine('mariadb+mariadbconnector://username:password@db:3306/project', echo=False)
    cnn = engine.connect()

    metadata = MetaData()
    domain = Table('Domain', metadata, autoload = True, autoload_with=engine)
    domain_vuln = Table('Domain_Vuln', metadata, autoload = True, autoload_with=engine)
    users = Table('Users', metadata, autoload = True, autoload_with=engine)
    domain_users = Table('Domain_Users', metadata, autoload = True, autoload_with=engine)

    if ' ' in domainNames:
        domainsList = domainNames.split(' ')
    else:
        domainsList = [domainNames]

    users_emails = dict()
    ip_users = dict()

    for dom in domainsList:
        select = domain.select().where(domain.c.Domain_name == dom)
        result = cnn.execute(select)
        info = result.fetchall()
        ip = info[0][0]
        select = domain_users.select().where(domain_users.c.FK_Domain == ip)
        result = cnn.execute(select)
        info = result.fetchall()
        if info != []:
            ip_users[ip] = list()
            for tuple in info:
                user = tuple[1]
                ip_users[ip].append(user)
                if user not in users_emails.keys():
                    select = users.select().where(users.c.Username == user)
                    result = cnn.execute(select)
                    userinfo = result.fetchall()
                    users_emails[user] = userinfo[0][1]
    
    session = smtplib.SMTP('smtp-mail.outlook.com', 587)
    session.starttls()
    session.login(MY_ADDRESS, PASSWORD)
    print(ip_users);
    for ip in ip_users.keys():
        select = domain_vuln.select().where(domain_vuln.c.FK_Domain == ip).where(domain_vuln.c.State == 'Not Fixed')
        result = cnn.execute(select)
        domainvulninfo = result.fetchall()
        cves = list(tuple[1] for tuple in domainvulninfo)
        if cves == []:
            cves = ''
        
        #for each contact, send the email:
        for user in ip_users[ip]:
            user_email =  users_emails[user]
            msg = MIMEMultipart()
            #setup the parameters of the message
            msg['FROM'] = MY_ADDRESS
            msg['To'] = user_email
            msg['Subject'] = "Vulnerabilities found in your machine"

            #add in the message body
            
            message = message_template.substitute(PERSON_NAME = user, IP_ADDRESS = ip, CVEs = cves)

            msg.attach(MIMEText(message, 'plain'))

            
            #send the message via the server set up earlier
            
            session.sendmail(MY_ADDRESS, user_email, msg.as_string())

            print("mail sent")
            del msg
    session.quit()

def get_contacts(filename):
    names = []
    emails =[]
    ips = []
    with open(filename, mode='r', encoding='utf-8') as contacts_file:
        for a_contact in contacts_file:
            names.append(a_contact.split()[0])
            emails.append(a_contact.split()[1])
            ips.append(a_contact.split()[2])
    return names, emails, ips

def read_template(filename):
    with open(filename, 'r', encoding='utf-8') as template_file:
        template_file_content = template_file.read()
    return Template(template_file_content)