from django.shortcuts import render, redirect
from django.contrib.auth.decorators import login_required
from sqlalchemy import *
from sqlalchemy import create_engine, MetaData, Table, Column, Integer, String, ForeignKey
from sqlalchemy.ext.declarative import declarative_base
from sqlalchemy.orm import sessionmaker, relationship

@login_required(login_url='/login/')
def managedoms(request):
    context = {}

    engine = create_engine('mariadb+mariadbconnector://username:password@db:3306/project', echo=False)
    cnn = engine.connect()

    metadata = MetaData()
    domain_users = Table('Domain_Users', metadata, autoload = True, autoload_with=engine)
    users = Table('Users', metadata, autoload = True, autoload_with=engine)

    x = str(request.user)
    select = users.select().where(users.c.Username == x)
    result = cnn.execute(select)
    info = result.fetchall()
    role = info[0][2]

    if role != 'admin':
        return redirect('/dashboard/')
        
    txt = request.POST.get('UserIPButton', None)
    if txt != None:
        y = txt.split("\t")
        username = y[0]
        ip = y[1]

        domain = Table('Domain', metadata, autoload = True, autoload_with=engine)
        users = Table('Users', metadata, autoload = True, autoload_with=engine)

        select = users.select().where(users.c.Username == username)
        result = cnn.execute(select)
        user = result.fetchall()

        select = domain.select().where(domain.c.IP_address == ip)
        result = cnn.execute(select)
        dom = result.fetchall()

        if user != [] and dom != []:
            select = domain_users.select().where(domain_users.c.FK_Domain == ip).where(domain_users.c.FK_Users == username)
            result = cnn.execute(select)
            domuserfound = result.fetchall()
            if domuserfound == []:
                insert = domain_users.insert().values(FK_Domain = ip, FK_Users = username, State = 'Active')
                cnn.execute(insert)
    
    else:
        txt = request.POST.get('pendingButton', None)
        if txt != None:
            y = txt.split(',')
            action = y[0]
            username = y[1]
            ip = y[2]
            if action == 'accept':
                modify_row = domain_users.update().where(domain_users.c.FK_Domain == ip).where(domain_users.c.FK_Users == username).values(State = 'Active')
                cnn.execute(modify_row)
            elif action == 'reject':
                delete = domain_users.delete().where(domain_users.c.FK_Domain == ip).where(domain_users.c.FK_Users == username).where(domain_users.c.State == 'Pending')
                cnn.execute(delete)
        else:
            txt = request.POST.get('deleteButton', None)
            if txt != None:
                y = txt.split(",")
                username = y[0]
                ip = y[1]
                delete = domain_users.delete().where(domain_users.c.FK_Domain == ip).where(domain_users.c.FK_Users == username).where(domain_users.c.State == 'Active')
                cnn.execute(delete)

    dom_users = dict()

    select = domain_users.select()
    result = cnn.execute(select)
    info = result.fetchall()

    i = 0
    for tuple in info:
        domuserdict = dict()
        domuserdict['domain'] = tuple[0]
        domuserdict['user'] = tuple[1]
        domuserdict['state'] = tuple[2]
        dom_users[str(i)] = domuserdict
        i += 1

    context['dom_users'] = dom_users

    return render(request, 'manager.html', context)

@login_required(login_url='/login/')
def usermanagedoms(request):
    context = {}

    engine = create_engine('mariadb+mariadbconnector://username:password@db:3306/project', echo=False)
    cnn = engine.connect()

    metadata = MetaData()
    domain_users = Table('Domain_Users', metadata, autoload = True, autoload_with=engine)
    users = Table('Users', metadata, autoload = True, autoload_with=engine)

    x = str(request.user)
    select = users.select().where(users.c.Username == x)
    result = cnn.execute(select)
    info = result.fetchall()
    role = info[0][2]

    if role != 'user':
        return redirect('/dashboard/')
        
    txt = request.POST.get('UserIPButton', None)
    if txt != None:
        username = x
        ip = txt

        domain = Table('Domain', metadata, autoload = True, autoload_with=engine)
        users = Table('Users', metadata, autoload = True, autoload_with=engine)

        select = users.select().where(users.c.Username == username)
        result = cnn.execute(select)
        user = result.fetchall()

        select = domain.select().where(domain.c.IP_address == ip)
        result = cnn.execute(select)
        dom = result.fetchall()

        if user != [] and dom != []:
            select = domain_users.select().where(domain_users.c.FK_Domain == ip).where(domain_users.c.FK_Users == username)
            result = cnn.execute(select)
            domuserfound = result.fetchall()
            if domuserfound == []:
                insert = domain_users.insert().values(FK_Domain = ip, FK_Users = username, State = 'Pending')
                cnn.execute(insert)
    
    else:
        txt = request.POST.get('pendingButton', None)
        if txt != None:
            username = x
            ip = txt
            delete = domain_users.delete().where(domain_users.c.FK_Domain == ip).where(domain_users.c.FK_Users == username).where(domain_users.c.State == 'Pending')
            cnn.execute(delete)

    dom_users = dict()

    select = domain_users.select().where(domain_users.c.FK_Users == x)
    result = cnn.execute(select)
    info = result.fetchall()

    i = 0
    for tuple in info:
        domuserdict = dict()
        domuserdict['domain'] = tuple[0]
        domuserdict['user'] = tuple[1]
        domuserdict['state'] = tuple[2]
        dom_users[str(i)] = domuserdict
        i += 1

    context['dom_users'] = dom_users

    return render(request, 'manager_user.html', context)



