import argparse
import socket 
import sys
import pickle
import json
import os
import struct

""" This program will always be up and will recieve information sent by the server
    Only processes json files, other ones will be discarded
    
"""

class Server():
    """
        Maximum data SIZE sent at one time its 1024
        Data is encoded with utf-8

    Raises:
        argparse.ArgumentTypeError: If its not a JSON file it will raise this error and wait for another file
    """
    SIZE = 1024
    FORMAT = 'utf-8'
    
    # files = glob.glob('./*.json')
    # for file in files:
    #     print(f'[DELETE] File {file} as been deleted')
    #     os.remove(file)
    
    def receive_data(self, conn):
        """Decode de Data sent by the client

        Args:
            conn (_type_): client connection

        Returns:
            _type_: data processed and decoded
        """
        try:
            data_size = struct.unpack('>I', conn.recv(4))[0]
            received_payload = b""
            reamining_payload_size = data_size
            while reamining_payload_size != 0:
                received_payload += conn.recv(reamining_payload_size)
                reamining_payload_size = data_size - len(received_payload)
            data = pickle.loads(received_payload)

            return data
        except struct as e:
            print(e)
            return None


    def Start_Connection(self, IP='127.0.0.1', PORT=1234):
        """Puts the server in listening mode. It waits for connections to be established

        Args:
            IP (str, optional): Server IP. Defaults to '127.0.0.1'.
            PORT (int, optional): Server PORT. Defaults to 1234.

        Raises:
            argparse.ArgumentTypeError: If its not a JSON file it will raise this error and wait for another file
        """
        print('[STARTING] Server is starting...')
        print(f'IP: {IP} PORT: {PORT}')
        ADDR = (IP, PORT)
        
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as server:
            try:
                server.bind(ADDR)
                
                server.listen(2)
                print('[LISTENING] Server is Listening')
                
                while(True):
                    try:  
                        conn, addr = server.accept()
                        print(f'[NEW CONNECTION] {addr} connected')
                        
                        filename = conn.recv(self.SIZE).decode(self.FORMAT)
                        if os.path.isfile(filename):
                            print(f'File {filename} already exists')
                            print(f'[DELETING] {filename}...')
                            os.remove(filename)
                        
                        if not filename.endswith('.json'):
                                raise argparse.ArgumentTypeError(
                                    print('Not a JSON file')
                                )
                                
                        with open(filename, 'w') as file:
                            
                            
                            conn.send('Filename recieved'.encode(self.FORMAT))
                            data = self.receive_data(conn)
                            print(f'[RECV] Receiving file data')
                            json.dump(data, file, indent=4)
                            conn.send(f'File data received'.encode(self.FORMAT))
                            print(f'[DATA RECIEVED] All data has been recieved')
                            
                    except socket.error or struct.error or AttributeError as e:
                        print(e)
                        continue
                    except argparse.ArgumentTypeError:
                        conn.send(f'[SERVER] Not a JSON file. Must be a JSON file')
                        continue
                    
            except KeyboardInterrupt:
                print('[EXITING] Server is exiting')
                server.shutdown(socket.SHUT_RDWR)
                server.close()
                
s = Server()
s.Start_Connection()